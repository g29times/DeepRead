<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeepRead 金句热力（文章内联 Mock）</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --grid: rgba(255,255,255,0.10);
      --accent: #7c5cff;
      --good: #2dd4bf;
      --warn: #f59e0b;
      --shadow: 0 12px 40px rgba(0,0,0,0.40);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Microsoft YaHei", Arial, sans-serif;

      --hl-bg: rgba(124, 92, 255, 0.18);
      --hl-bg-weak: rgba(124, 92, 255, 0.10);
      --hl-border: rgba(124, 92, 255, 0.65);
      --hl-border-weak: rgba(124, 92, 255, 0.30);

      --bar-bg: rgba(255,255,255,0.08);

      --minimap-x: 0px;
    }

    *{ box-sizing: border-box; }

    body{
      margin: 0;
      font-family: var(--font);
      color: var(--text);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(124, 92, 255, 0.22), transparent 55%),
        radial-gradient(900px 700px at 90% 30%, rgba(45, 212, 191, 0.18), transparent 55%),
        radial-gradient(700px 700px at 50% 100%, rgba(239, 68, 68, 0.10), transparent 60%),
        var(--bg);
      min-height: 100vh;
    }

    .wrap{
      max-width: 1240px;
      margin: 0 auto;
      padding: 18px;
    }

    .header{
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 14px;
    }

    .title{
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    h1{
      font-size: 18px;
      line-height: 1.2;
      margin: 0;
      letter-spacing: 0.2px;
    }

    .subtitle{
      font-size: 12px;
      color: var(--muted);
      margin: 0;
      line-height: 1.45;
      max-width: 860px;
    }

    .toolbar{
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .minimap-actions{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .minimap-actions button{
      width: 34px;
      height: 34px;
      padding: 0;
      border-radius: 12px;
      font-size: 16px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .minimap-actions button:disabled{
      opacity: 0.45;
      cursor: not-allowed;
    }

    button{
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.07);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: transform .05s ease, background .12s ease, border-color .12s ease;
      user-select: none;
    }
    button:hover{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.24); }
    button:active{ transform: translateY(1px); }

    .layout{
      display: grid;
      grid-template-columns: 100px 1fr 360px;
      gap: 12px;
      align-items: start;
    }

    .card{
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card-head{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .card-head .label{
      font-size: 12px;
      color: var(--muted);
    }

    /* Left mini-map */
    .minimap{
      position: sticky;
      top: 12px;
      height: calc(100vh - 24px);
      padding: 10px;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 10px;
      transform: translateX(var(--minimap-x));
      z-index: 30;
    }

    .minimap-resize{
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      cursor: grab;
      position: relative;
      overflow: hidden;
    }

    .minimap-resize:active{
      cursor: grabbing;
    }

    .minimap-resize::after{
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(124,92,255,0.20), rgba(45,212,191,0.18));
      opacity: 0;
      transition: opacity .12s ease;
    }

    .minimap-resize:hover::after{
      opacity: 1;
    }

    .minimap .cap{
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .minimap-bar{
      position: relative;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      overflow: hidden;
      min-height: 0;
      height: 100%;
    }

    .minimap-rail{
      position: absolute;
      inset: 0;
      background:
        linear-gradient(180deg,
          rgba(16, 185, 129, 0.10),
          rgba(250, 204, 21, 0.10),
          rgba(239, 68, 68, 0.10)
        ),
        linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    }

    .minimap-dot{
      position: absolute;
      left: 8px;
      right: 8px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(124, 92, 255, 0.18);
      cursor: pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
    }

    .minimap-dot:hover{ transform: scaleX(1.05); }

    .minimap-dot.is-selected{
      border-color: rgba(124, 92, 255, 0.75);
      background: rgba(124, 92, 255, 0.42);
      box-shadow: 0 0 0 6px rgba(124,92,255,0.10);
    }

    .minimap-dot.is-related{
      border-color: rgba(45, 212, 191, 0.55);
      background: rgba(45, 212, 191, 0.28);
    }

    .minimap-dot.is-related.strong{
      background: rgba(45, 212, 191, 0.40);
      border-color: rgba(45, 212, 191, 0.75);
    }

    .minimap-view{
      position: absolute;
      left: 4px;
      right: 4px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.05);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
      pointer-events: none;
    }

    .minimap-note{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* Article */
    .article{
      padding: 16px 18px;
    }

    .article h2{
      margin: 0 0 4px 0;
      font-size: 22px;
      letter-spacing: .2px;
    }

    .article .meta{
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 18px;
    }

    .article h3{
      margin: 18px 0 10px 0;
      font-size: 16px;
      color: rgba(255,255,255,0.92);
    }

    .article p{
      margin: 0 0 12px 0;
      line-height: 1.85;
      font-size: 14px;
      color: rgba(255,255,255,0.90);
    }

    /* Highlighted quote (golden sentence) */
    .gq{
      padding: 2px 4px;
      border-radius: 8px;
      background: var(--hl-bg-weak);
      border: 1px solid transparent;
      cursor: pointer;
      transition: background .12s ease, border-color .12s ease, box-shadow .12s ease;
    }

    .gq:hover{
      background: var(--hl-bg);
      border-color: rgba(255,255,255,0.10);
    }

    .gq.is-selected{
      background: rgba(124, 92, 255, 0.28);
      border-color: var(--hl-border);
      box-shadow: 0 0 0 6px rgba(124, 92, 255, 0.10);
    }

    .gq.is-related{
      background: rgba(45, 212, 191, 0.18);
      border-color: rgba(45, 212, 191, 0.45);
    }

    .gq.is-related.strong{
      background: rgba(45, 212, 191, 0.26);
      border-color: rgba(45, 212, 191, 0.70);
    }

    /* Right panel */
    .side{
      position: sticky;
      top: 12px;
      height: calc(100vh - 24px);
      display: grid;
      grid-template-rows: auto 1fr;
      z-index: 10;
    }

    .side-body{
      padding: 14px;
      overflow: auto;
    }

    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.03);
    }

    .picked{
      display: grid;
      gap: 10px;
      margin-bottom: 12px;
    }

    .badge{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(124, 92, 255, 0.10);
      border: 1px solid rgba(124, 92, 255, 0.35);
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      width: fit-content;
    }

    .quote{
      background: var(--panel2);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 12px;
      line-height: 1.55;
      font-size: 13px;
    }

    .quote .meta{
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .quote .text{
      color: rgba(255,255,255,0.92);
    }

    .related-list{
      display: grid;
      gap: 10px;
      margin-top: 10px;
    }

    .rel-card{
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      display: grid;
      gap: 10px;
    }

    .rel-head{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    .rel-head .left{
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }

    .pill{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.86);
      font-size: 11px;
    }

    .heat{
      height: 8px;
      border-radius: 999px;
      background: var(--bar-bg);
      border: 1px solid rgba(255,255,255,0.10);
      overflow: hidden;
    }

    .heat > .fill{
      height: 100%;
      width: 0;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(45,212,191,0.45), rgba(124,92,255,0.65));
      transition: width .12s ease;
    }

    .rel-actions{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .linkbtn{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.88);
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .linkbtn:hover{ background: rgba(255,255,255,0.10); }

    .muted{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
    }

    @media (max-width: 1060px){
      .layout{ grid-template-columns: 1fr; }
      .minimap{ position: relative; height: auto; }
      .side{ position: relative; height: auto; }
      .minimap-bar{ min-height: 160px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">
        <h1>金句热力（文章内联 Mock）</h1>
        <p class="subtitle">点击正文中的划线金句，会在右侧固定栏展示与它相关的其它金句（默认等强/可手动标注权重）。左侧卡尺标出金句在文章中的位置，可点击跳转。<br>
        DEV说明：这里的“金句”只是示例标注（q1/q2/q3）。后续接入真实页面时，可以把 DOM 里被你划线/收藏的片段替换成同样结构的 <code>&lt;span class="gq" data-qid="..."&gt;</code>。<br>
        </p>
      </div>
    </div>

    <div class="layout">
      <div class="card minimap" aria-label="金句卡尺">
        <div class="minimap-resize" id="minimapPan" title="拖动左右移动卡尺"></div>
        <div class="minimap-actions" aria-label="操作按钮">
          <button id="btnApplySel" disabled title="选中划线">+</button>
          <button id="btnClear" title="占位">*</button>
        </div>
        <div class="cap">
          <span class="muted" id="mmCount">—</span>
        </div>
        <div class="minimap-bar" id="minimapBar">
          <div class="minimap-rail"></div>
          <div class="minimap-view" id="minimapView"></div>
        </div>
      </div>

      <div class="card" aria-label="文章正文">
        <div class="article" id="article">
          <h2>羊舍一夕</h2>
          <div class="meta">（又名：四个孩子和一个夜晚） · 汪曾祺</div>

          <h3>一、夜晚</h3>

          <p>火车过来了。</p>

          <p>“216！往北京的上行车，”老九说。</p>

          <p>
            于是他们放下手里的工作，一起听火车。老九和小吕都好像看见：<span class="gq" data-qid="q1">先是一个雪亮的大灯，亮得叫人眼睛发胀。</span>大灯好像在拼命地往外冒光，而且冒着气，嗤嗤地响。乌黑的铁，锃黄的铜。然后是绿色的车身，排山倒海地冲过来。<span class="gq" data-qid="q3">车窗蜜黄色的灯光连续地映在果园东边的树墙子上，一方块，一方块，川流不息地追赶着</span>……每回看到灯光那样猛烈地从树墙子上刮过去，你总觉得会刮下满地枝叶来似的。可是火车一过，还是那样：树墙子显得格外的安详，格外的绿，真怪。
          </p>

          <p>
            这些，老九和小吕都太熟悉了。夏天，他们睡得晚，老是到路口去看火车。可现在是冬天了。那么，现在是什么样子呢？小吕想象，<span class="gq" data-qid="q2">灯光一定会从树墙子的枝叶空隙处漏进来，落到果园的地面上来吧。</span>可能！他想象着那灯光映在大梨树地间作的葱畦里，照着一地的大葱蓬松的，干的，发白的叶子……车轮的声音逐渐模糊成为一片，像刮过一阵大风一样，过去
            “十点四十七，”老九说。
            老九在附近的山头上放了好几年羊了，他知道每一趟火车的时刻。
          </p>

          <p>留孩说：“贵甲哥怎么还不回来？”</p>

          <p>老九说：“他又排戏去了，一定回来得晚。”</p>

          <p>小吕说：“这是什么奶哥！奶弟来了也不陪着，昨天是找羊，今天又去排戏！”</p>

          <p>留孩说：“没关系，以后我们就常在一起了。”</p>

          <p>老九说：“咱们烧山药吃，一边说话，一边等他。小吕，不是还有一包高山顶①吗？坐上！外屋缸里还有没有水？”“有！”</p>

          <p>于是三个人一起动手：小吕拿沙锅舀了多半锅水，抓起一把高山顶来撮在里面。这是老九放羊时摘来的。老九从麻袋里掏山药——他们在山坡上自己种的。留孩把炉子通了通，又加了点煤。</p>

          <p>屋里一顺排了五张木床，联成一个大炕。一张是张士林的，他到狼山给场里买果树苗子去了。隔壁还有一间小屋，锅灶俱全，是老羊倌住的。老羊倌请了假，看他的孙子去了。今天这里只剩下四个孩子：他们三个，和那个正在排戏的。</p>

          <p>屋里有一盏自造的煤油灯——老九用墨水瓶子改造的，一个炉子。外边还有一间空屋，是个农具仓库，放着硫铵、石灰、DDT、铁桶、木叉、喷雾器……外屋门插着。门外，右边是羊圈，里边卧着四百只羊；前边是果园，什么都没有了，只剩下一点葱，还有一堆没有窖好的蔓菁。现在什么也看不见，外边是无边的昏黑。方圆左近，就只有这个半山坡上有一点点亮光。夜，正在深浓起来。”</p>

          <div style="margin-top:12px;line-height:1.8;">
            <span>（非 p 结构示例）这一段用的是 </span><span>div + span + br</span><span> 来组织。</span><br/>
            <span>你可以在这一段里随便拖选一段文字，然后点左侧卡尺上的“+”确认生成划线。</span><br/>
            <span>如果你跨出这个 div 去选到上一段/下一段，按方案 A 应该会被拒绝（不会进入待确认状态）。</span>
          </div>


        </div>
      </div>

      <div class="card side" aria-label="关联侧栏">
        <div class="card-head">
          <div class="label">关联金句</div>
          <div class="label" id="picked">未选择</div>
        </div>
        <div class="side-body" id="sideBody">
          <div class="hint" id="hint">
            点击正文里任意一条金句（有底色的划线区域）。我会：
            <div class="muted" style="margin-top:6px;">
              1) 在右侧列出与它相关的金句（默认等强）<br/>
              2) 在正文内对相关句做轻高亮<br/>
              3) 在左侧卡尺上点亮相关位置
            </div>
          </div>

          <div class="picked" id="pickedBox" style="display:none;"></div>
          <div class="related-list" id="relList" style="display:none;"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 手动标注的数据结构（Mock）
    // 说明：
    // - qid 对应正文里 data-qid 的金句节点
    // - text 用于侧栏展示（实际接入时也可直接从 DOM 取）
    // - links: 这个 qid 和其它 qid 的关系强度(0..1)，第一版可默认等强

    const QUOTES = {
      q1: { text: "先是一个雪亮的大灯，亮得叫人眼睛发胀。", links: { q2: 0, q3: 0 } },
      q2: { text: "灯光一定会从树墙子的枝叶空隙处漏进来，落到果园的地面上来吧。", links: { q1: 0, q3: 0 } },
      q3: { text: "车窗蜜黄色的灯光连续地映在果园东边的树墙子上，一方块，一方块，川流不息地追赶着", links: { q1: 0, q2: 0 } },
    };

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    const elArticle = $("#article");
    const elPicked = $("#picked");
    const elPickedBox = $("#pickedBox");
    const elRelList = $("#relList");
    const elHint = $("#hint");

    const elMinimapBar = $("#minimapBar");
    const elMinimapView = $("#minimapView");
    const elMmCount = $("#mmCount");
    const elMinimapPan = $("#minimapPan");

    let selectedQid = null;
    let userQuoteSeq = 1;
    let pendingSelection = null;

    const elBtnApplySel = $("#btnApplySel");

    const STORAGE_KEY_QUOTES = "deepread_quotes";
    const STORAGE_KEY_USER_HIGHLIGHTS = "deepread_user_highlights";

    function escapeHtml(s){
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function clamp01(x){
      const n = Number(x);
      if (Number.isNaN(n)) return 0;
      return Math.max(0, Math.min(1, n));
    }

    function randomWeight(){
      return Math.round(Math.random() * 100) / 100;
    }

    function ensureSymLink(a, b, w){
      if (!a || !b) return;
      if (!QUOTES[a] || !QUOTES[b]) return;
      if (!QUOTES[a].links) QUOTES[a].links = {};
      if (!QUOTES[b].links) QUOTES[b].links = {};
      const ww = clamp01(w);
      QUOTES[a].links[b] = ww;
      QUOTES[b].links[a] = ww;
    }

    function randomizeExistingLinks(){
      const ids = Object.keys(QUOTES);
      for (let i = 0; i < ids.length; i++){
        for (let j = i + 1; j < ids.length; j++){
          ensureSymLink(ids[i], ids[j], randomWeight());
        }
      }
    }

    function weightToHeatColor(w){
      // 0..1: green -> yellow -> red
      const ww = clamp01(w);
      const hue = 120 - ww * 120; // 120(green) -> 0(red)
      const sat = 85;
      const light = 52;
      return `hsl(${hue} ${sat}% ${light}%)`;
    }

    function getMinimapX(){
      const raw = getComputedStyle(document.documentElement).getPropertyValue("--minimap-x");
      const v = parseInt(String(raw || "").trim(), 10);
      return Number.isFinite(v) ? v : 0;
    }

    function setMinimapX(px){
      const x = Math.round(Number(px) || 0);
      document.documentElement.style.setProperty("--minimap-x", `${x}px`);
      try{
        localStorage.setItem("deepread_minimap_x", String(x));
      }catch{}
    }

    function restoreMinimapX(){
      try{
        const v = parseInt(localStorage.getItem("deepread_minimap_x") || "", 10);
        if (Number.isFinite(v)){
          setMinimapX(v);
        }
      }catch{}
    }

    function bindMinimapPan(){
      if (!elMinimapPan) return;
      let dragging = false;
      let startX = 0;
      let startOffset = 0;
      let minOffset = null;
      let maxOffset = null;

      elMinimapPan.addEventListener("pointerdown", (e) => {
        if (window.matchMedia("(max-width: 1060px)").matches) return;
        const elWrap = document.querySelector(".wrap");
        const elMinimapCard = document.querySelector(".card.minimap");
        if (!elWrap || !elMinimapCard) return;

        const wrapRect = elWrap.getBoundingClientRect();
        const mmRect = elMinimapCard.getBoundingClientRect();

        dragging = true;
        startX = e.clientX;
        startOffset = getMinimapX();

        // 计算本次拖动允许的偏移范围：
        // - 左边界：minimap 左边不小于 wrap 左边
        // - 右边界：minimap 右边不大于 wrap 右边
        // 用“当前偏移 + 可移动距离”来得到绝对偏移范围
        const canMoveLeft = mmRect.left - wrapRect.left;
        const canMoveRight = wrapRect.right - mmRect.right;
        minOffset = startOffset - canMoveLeft;
        maxOffset = startOffset + canMoveRight;

        elMinimapPan.setPointerCapture(e.pointerId);
        e.preventDefault();
      });

      elMinimapPan.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        let next = startOffset + dx;
        if (typeof minOffset === "number") next = Math.max(minOffset, next);
        if (typeof maxOffset === "number") next = Math.min(maxOffset, next);
        setMinimapX(next);
      });

      function endDrag(){
        dragging = false;
        minOffset = null;
        maxOffset = null;
      }

      elMinimapPan.addEventListener("pointerup", endDrag);
      elMinimapPan.addEventListener("pointercancel", endDrag);
    }

    function getQuoteEl(qid){
      return elArticle.querySelector(`.gq[data-qid="${qid}"]`);
    }

    function allQuoteEls(){
      return $$(".gq[data-qid]");
    }

    function setPendingSelection(next){
      pendingSelection = next;
      if (!elBtnApplySel) return;
      elBtnApplySel.disabled = !pendingSelection;
    }

    function closestBlockContainer(node){
      if (!node) return null;
      let el = (node.nodeType === Node.ELEMENT_NODE) ? node : node.parentElement;
      if (!el) return null;

      // 优先匹配常见块级承载容器
      const quick = el.closest("p,li,blockquote,pre,h1,h2,h3,h4,h5,h6,td,th,div");
      if (quick && elArticle && elArticle.contains(quick) && quick !== elArticle) return quick;

      // 兜底：向上找第一个非 inline 的元素作为容器
      while (el && elArticle && el !== elArticle){
        const cs = getComputedStyle(el);
        const display = cs ? cs.display : "";
        if (display && display !== "inline" && display !== "contents") return el;
        el = el.parentElement;
      }
      return null;
    }

    function isRangeInArticle(range){
      if (!range) return false;
      const sc = range.startContainer;
      const ec = range.endContainer;
      return elArticle.contains(sc) && elArticle.contains(ec);
    }

    function getTextNodesIn(el){
      const out = [];
      const tw = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
        acceptNode: (n) => {
          if (!n.nodeValue) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      });
      let n;
      while ((n = tw.nextNode())) out.push(n);
      return out;
    }

    function calcOffsetWithin(el, container, offset){
      const nodes = getTextNodesIn(el);
      let acc = 0;
      for (const n of nodes){
        if (n === container) return acc + offset;
        acc += n.nodeValue.length;
      }
      // 如果 container 不是文本节点（极少数情况），尝试定位到其前一个文本节点
      if (container && container.nodeType === Node.ELEMENT_NODE){
        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
        let last = null;
        let cur;
        while ((cur = walker.nextNode())){
          if (container.contains(cur)){
            // offset 指向 element child index；这里退化为 element 起始
            return acc;
          }
          last = cur;
          acc += cur.nodeValue.length;
        }
        if (last) return acc;
      }
      return acc;
    }

    function getSpanOffsets(spanEl){
      if (!spanEl) return null;
      const containerEl = closestBlockContainer(spanEl);
      if (!containerEl) return null;

      try{
        const rStart = document.createRange();
        rStart.selectNodeContents(containerEl);
        rStart.setEndBefore(spanEl);
        const start = rStart.toString().length;

        const rEnd = document.createRange();
        rEnd.selectNodeContents(containerEl);
        rEnd.setEndAfter(spanEl);
        const end = rEnd.toString().length;

        return { start, end };
      }catch{
        return null;
      }
    }

    function nodeAtOffset(el, targetOffset){
      const nodes = getTextNodesIn(el);
      let acc = 0;
      for (const n of nodes){
        const len = n.nodeValue.length;
        if (targetOffset <= acc + len){
          return { node: n, offset: Math.max(0, targetOffset - acc) };
        }
        acc += len;
      }
      // 落在末尾
      if (nodes.length === 0) return null;
      const last = nodes[nodes.length - 1];
      return { node: last, offset: last.nodeValue.length };
    }

    function unwrapSpan(el){
      const text = document.createTextNode(el.textContent || "");
      el.replaceWith(text);
    }

    function normalizeRangeOffsets(a, b){
      const s = Math.min(a, b);
      const e = Math.max(a, b);
      return { start: s, end: e };
    }

    function generateUserQid(){
      const seq = userQuoteSeq++;
      return `uq${seq}`;
    }

    function saveToLocalStorage(){
      try{
        // 保存 QUOTES 数据结构
        localStorage.setItem(STORAGE_KEY_QUOTES, JSON.stringify(QUOTES));
        
        // 保存用户新增划线的位置信息（用于恢复 DOM）
        const userHighlights = [];
        for (const qid of Object.keys(QUOTES)){
          if (!qid.startsWith("uq")) continue; // 只保存用户新增的
          const el = getQuoteEl(qid);
          if (!el) continue;
          
          const container = closestBlockContainer(el);
          if (!container) continue;
          
          const containerPath = getElementPath(container);
          const offsets = getSpanOffsets(el);
          if (!offsets || !containerPath) continue;
          
          userHighlights.push({
            qid,
            containerPath,
            start: offsets.start,
            end: offsets.end,
            text: QUOTES[qid].text
          });
        }
        localStorage.setItem(STORAGE_KEY_USER_HIGHLIGHTS, JSON.stringify(userHighlights));
      }catch(err){
        console.warn("保存到 localStorage 失败:", err);
      }
    }

    function getElementPath(el){
      // 生成一个简单的选择器路径（基于 id/class/tag + nth-child）
      const path = [];
      let current = el;
      while (current && current !== elArticle && current !== document.body){
        let selector = current.tagName.toLowerCase();
        if (current.id) selector += `#${current.id}`;
        else if (current.className) selector += `.${Array.from(current.classList).join(".")}`;
        
        // 添加 nth-child 以提高精确度
        const parent = current.parentElement;
        if (parent){
          const siblings = Array.from(parent.children);
          const index = siblings.indexOf(current) + 1;
          selector += `:nth-child(${index})`;
        }
        
        path.unshift(selector);
        current = current.parentElement;
      }
      return path.join(" > ");
    }

    function restoreFromLocalStorage(){
      try{
        // 1) 恢复 QUOTES 数据
        const savedQuotes = localStorage.getItem(STORAGE_KEY_QUOTES);
        if (savedQuotes){
          const parsed = JSON.parse(savedQuotes);
          // 合并到现有 QUOTES（保留预设的 q1/q2/q3）
          for (const [qid, data] of Object.entries(parsed)){
            if (qid.startsWith("uq")){
              QUOTES[qid] = data;
              // 更新 userQuoteSeq 避免 ID 冲突
              const num = parseInt(qid.substring(2), 10);
              if (!isNaN(num) && num >= userQuoteSeq){
                userQuoteSeq = num + 1;
              }
            }
          }
        }
        
        // 2) 恢复用户划线的 DOM 包裹
        const savedHighlights = localStorage.getItem(STORAGE_KEY_USER_HIGHLIGHTS);
        if (savedHighlights){
          const highlights = JSON.parse(savedHighlights);
          for (const h of highlights){
            try{
              const container = document.querySelector(h.containerPath);
              if (!container || !elArticle.contains(container)) continue;
              
              // 检查是否已经存在（避免重复包裹）
              if (getQuoteEl(h.qid)) continue;
              
              // 重新包裹
              const startLoc = nodeAtOffset(container, h.start);
              const endLoc = nodeAtOffset(container, h.end);
              if (!startLoc || !endLoc) continue;
              
              const range = document.createRange();
              range.setStart(startLoc.node, startLoc.offset);
              range.setEnd(endLoc.node, endLoc.offset);
              
              const span = document.createElement("span");
              span.className = "gq";
              span.setAttribute("data-qid", h.qid);
              
              const frag = range.extractContents();
              span.appendChild(frag);
              range.insertNode(span);
            }catch(err){
              console.warn(`恢复划线 ${h.qid} 失败:`, err);
            }
          }
        }
      }catch(err){
        console.warn("从 localStorage 恢复失败:", err);
      }
    }

    function addRandomLinksForNewQid(newQid){
      if (!newQid || !QUOTES[newQid]) return;
      for (const otherQid of Object.keys(QUOTES)){
        if (otherQid === newQid) continue;
        ensureSymLink(newQid, otherQid, randomWeight());
      }
    }

    function addOrReplaceHighlightInContainer(containerEl, start, end){
      if (!containerEl) return null;
      const fullTextLen = (containerEl.textContent || "").length;
      const s = Math.max(0, Math.min(fullTextLen, start));
      const e = Math.max(0, Math.min(fullTextLen, end));
      if (e <= s) return null;

      // 1) 找到与 [s,e) 有任意重叠的现有 gq，并整体移除（最新覆盖旧的）
      const spans = Array.from(containerEl.querySelectorAll(".gq[data-qid]"));
      for (const sp of spans){
        const r = getSpanOffsets(sp);
        if (!r) continue;
        if (rangesOverlap({ start: s, end: e }, r)){
          unwrapSpan(sp);
        }
      }

      // 2) 重新定位 range（因为上面可能改动了 DOM）
      const startLoc = nodeAtOffset(containerEl, s);
      const endLoc = nodeAtOffset(containerEl, e);
      if (!startLoc || !endLoc) return null;

      const range = document.createRange();
      range.setStart(startLoc.node, startLoc.offset);
      range.setEnd(endLoc.node, endLoc.offset);

      const selectedText = range.toString();
      if (!selectedText || !selectedText.trim()) return null;

      const qid = generateUserQid();
      const span = document.createElement("span");
      span.className = "gq";
      span.setAttribute("data-qid", qid);

      const frag = range.extractContents();
      span.appendChild(frag);
      range.insertNode(span);

      QUOTES[qid] = { text: span.textContent || "", links: {} };
      addRandomLinksForNewQid(qid);
      saveToLocalStorage();
      return qid;
    }

    function setClassesForSelection(){
      const nodes = allQuoteEls();
      for (const n of nodes){
        n.classList.remove("is-selected", "is-related", "strong");
      }

      if (!selectedQid) return;

      const selEl = getQuoteEl(selectedQid);
      if (selEl) selEl.classList.add("is-selected");

      const links = (QUOTES[selectedQid] && QUOTES[selectedQid].links) || {};
      for (const [qid, w] of Object.entries(links)){
        const el = getQuoteEl(qid);
        if (!el) continue;
        el.classList.add("is-related");
        if (w >= 0.80) el.classList.add("strong");
      }
    }

    function renderSide(){
      if (!selectedQid){
        elPicked.textContent = "未选择";
        elHint.style.display = "block";
        elPickedBox.style.display = "none";
        elRelList.style.display = "none";
        elPickedBox.innerHTML = "";
        elRelList.innerHTML = "";
        return;
      }

      const q = QUOTES[selectedQid];
      elPicked.textContent = selectedQid;
      elHint.style.display = "none";

      elPickedBox.style.display = "block";
      elRelList.style.display = "block";

      elPickedBox.innerHTML = `
        <div class="badge">当前选中：${escapeHtml(selectedQid)}</div>
        <div class="quote">
          <div class="meta"><span>金句</span><span>${escapeHtml(selectedQid)}</span></div>
          <div class="text">${escapeHtml(q.text)}</div>
        </div>
      `;

      const links = Object.entries(q.links || {})
        .sort((a,b) => (b[1] || 0) - (a[1] || 0));

      if (links.length === 0){
        elRelList.innerHTML = `<div class="muted">没有标注关联。</div>`;
        return;
      }

      elRelList.innerHTML = links.map(([qid, w]) => {
        const other = QUOTES[qid];
        const score = typeof w === "number" ? w : 0;
        const pct = Math.round(Math.max(0, Math.min(1, score)) * 100);
        const color = weightToHeatColor(score);

        return `
          <div class="rel-card" data-target="${escapeHtml(qid)}">
            <div class="rel-head">
              <div class="left">
                <span class="pill">相关句 ${escapeHtml(qid)}</span>
                <span>强度 ${pct}%</span>
              </div>
              <span class="muted">默认/手动</span>
            </div>
            <div class="heat"><div class="fill" style="width:${pct}%;background:${color}"></div></div>
            <div class="muted">${escapeHtml(other?.text || "")}</div>
            <div class="rel-actions">
              <button class="linkbtn" data-jump="${escapeHtml(qid)}">定位到正文</button>
              <button class="linkbtn" data-select="${escapeHtml(qid)}">设为选中</button>
            </div>
          </div>
        `;
      }).join("");

      // 绑定事件（按钮）
      for (const btn of $$("button[data-jump]")){
        btn.addEventListener("click", (e) => {
          const qid = e.currentTarget.getAttribute("data-jump");
          jumpTo(qid);
        });
      }
      for (const btn of $$("button[data-select]")){
        btn.addEventListener("click", (e) => {
          const qid = e.currentTarget.getAttribute("data-select");
          selectQid(qid);
        });
      }
    }

    function jumpTo(qid){
      const el = getQuoteEl(qid);
      if (!el) return;
      el.scrollIntoView({ behavior: "smooth", block: "center" });

      // 给一个短暂的闪烁提示
      el.animate(
        [
          { boxShadow: "0 0 0 0 rgba(124,92,255,0.0)" },
          { boxShadow: "0 0 0 10px rgba(124,92,255,0.18)" },
          { boxShadow: "0 0 0 0 rgba(124,92,255,0.0)" },
        ],
        { duration: 520, easing: "ease-out" }
      );
    }

    function selectQid(qid){
      if (!qid || !QUOTES[qid]) return;
      selectedQid = qid;
      setClassesForSelection();
      renderSide();
      renderMinimapState();
    }

    function deleteQid(qid){
      if (!qid || !QUOTES[qid]) return;
      const el = getQuoteEl(qid);
      if (el) unwrapSpan(el);

      delete QUOTES[qid];
      for (const q of Object.values(QUOTES)){
        if (q && q.links && Object.prototype.hasOwnProperty.call(q.links, qid)){
          delete q.links[qid];
        }
      }

      if (selectedQid === qid) selectedQid = null;

      saveToLocalStorage();
      setClassesForSelection();
      renderSide();
      ensureMinimapDots();
      updateMinimapViewport();
      renderMinimapState();
    }

    function clearSelection(){
      selectedQid = null;
      setClassesForSelection();
      renderSide();
      renderMinimapState();
    }

    // --- Minimap ---
    // 用所有金句元素的 offsetTop/scrollHeight 来映射到 mini-bar 的百分比位置。

    function getDocMetrics(){
      const scrollEl = document.documentElement;
      const docH = scrollEl.scrollHeight;
      const winH = window.innerHeight;
      const y = window.scrollY || scrollEl.scrollTop || 0;
      return { docH, winH, y };
    }

    function positionForElement(el){
      // 相对于文章区域计算位置，而不是整个文档
      const articleRect = elArticle.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      const articleH = elArticle.scrollHeight || articleRect.height;
      if (articleH <= 0) return 0;
      const relTop = elRect.top - articleRect.top;
      const ratio = relTop / articleH;
      return Math.max(0, Math.min(1, ratio));
    }

    function updateMinimapViewport(){
      const { docH, winH, y } = getDocMetrics();
      const barH = elMinimapBar.clientHeight;
      if (!barH) return;

      const topRatio = docH ? (y / docH) : 0;
      const viewRatio = docH ? (winH / docH) : 0;

      const topPad = 5;
      const bottomPad = 5;
      const usableH = Math.max(1, barH - topPad - bottomPad);

      const topPx = Math.round(topPad + topRatio * usableH);
      const hPx = Math.max(18, Math.round(viewRatio * usableH));

      elMinimapView.style.top = `${topPx}px`;
      elMinimapView.style.height = `${hPx}px`;
    }

    function ensureMinimapDots(){
      // 清掉旧 dot
      for (const dot of $$(".minimap-dot")) dot.remove();

      const nodes = allQuoteEls();
      elMmCount.textContent = `${nodes.length} 句`;

      const barH = elMinimapBar.clientHeight;
      if (!barH) return;

      const topPad = 5;
      const bottomPad = 5;
      const usableH = Math.max(1, barH - topPad - bottomPad);

      for (const n of nodes){
        const qid = n.getAttribute("data-qid");
        const ratio = positionForElement(n);
        const topPx = Math.round(topPad + ratio * usableH);

        const dot = document.createElement("div");
        dot.className = "minimap-dot";
        dot.style.top = `${Math.max(topPad, Math.min(barH - bottomPad, topPx))}px`;
        dot.title = `${qid}: ${n.textContent || ""}`;
        dot.dataset.qid = qid;
        dot.addEventListener("click", () => {
          selectQid(qid);
          jumpTo(qid);
        });
        elMinimapBar.appendChild(dot);
      }
    }

    function renderMinimapState(){
      for (const dot of $$(".minimap-dot")){
        dot.classList.remove("is-selected", "is-related", "strong");
        dot.style.background = "";
        dot.style.borderColor = "";
      }

      if (!selectedQid) return;

      const selDot = elMinimapBar.querySelector(`.minimap-dot[data-qid="${selectedQid}"]`);
      if (selDot) selDot.classList.add("is-selected");

      const links = (QUOTES[selectedQid] && QUOTES[selectedQid].links) || {};
      for (const [qid, w] of Object.entries(links)){
        const d = elMinimapBar.querySelector(`.minimap-dot[data-qid="${qid}"]`);
        if (!d) continue;
        d.classList.add("is-related");
        const ww = clamp01(w);
        const c = weightToHeatColor(ww);
        d.style.background = c;
        d.style.borderColor = c;
        if (ww >= 0.80) d.classList.add("strong");
      }
    }

    // --- Init ---

    function bindClicksInArticle(){
      // 用事件代理支持动态新增的划线
      elArticle.addEventListener("click", (e) => {
        const hit = e.target && e.target.closest ? e.target.closest(".gq[data-qid]") : null;
        if (!hit || !elArticle.contains(hit)) return;
        const qid = hit.getAttribute("data-qid");
        if (!qid) return;

        if (selectedQid === qid){
          clearSelection();
          return;
        }

        selectQid(qid);
      });
    }

    function bindUserHighlighting(){
      document.addEventListener("mouseup", () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        if (sel.isCollapsed) return;

        const range = sel.getRangeAt(0);
        if (!isRangeInArticle(range)) return;

        const cStart = closestBlockContainer(range.startContainer);
        const cEnd = closestBlockContainer(range.endContainer);
        if (!cStart || !cEnd || cStart !== cEnd) return;

        const { start, end } = normalizeRangeOffsets(
          calcOffsetWithin(cStart, range.startContainer, range.startOffset),
          calcOffsetWithin(cStart, range.endContainer, range.endOffset)
        );

        // 仅缓存为待确认的选择，不直接生成划线，避免误操作
        const previewText = (range.toString() || "").trim();
        if (!previewText) return;
        setPendingSelection({ pEl: cStart, start, end, text: previewText });
      });
    }

    function applyPendingSelection(){
      if (!pendingSelection) return;
      const { pEl, start, end } = pendingSelection;
      const qid = addOrReplaceHighlightInContainer(pEl, start, end);
      setPendingSelection(null);
      const sel = window.getSelection();
      if (sel) sel.removeAllRanges();
      if (!qid) return;

      selectQid(qid);
      ensureMinimapDots();
      updateMinimapViewport();
      renderMinimapState();
    }

    function bindDeleteHotkey(){
      document.addEventListener("keydown", (e) => {
        if (!selectedQid) return;
        if (e.key !== "Backspace" && e.key !== "Delete") return;

        const tag = (e.target && e.target.tagName) ? String(e.target.tagName).toLowerCase() : "";
        const editable = (e.target && (e.target.isContentEditable || tag === "input" || tag === "textarea"));
        if (editable) return;

        e.preventDefault();
        deleteQid(selectedQid);
      });
    }

    function init(){
      // 从 localStorage 恢复用户数据
      restoreFromLocalStorage();
      
      // 初始化时把预设 q1/q2/q3 的权重随机化（对称）
      randomizeExistingLinks();

      restoreMinimapX();
      bindMinimapPan();

      bindClicksInArticle();
      bindUserHighlighting();
      bindDeleteHotkey();
      renderSide();

      // minimap 初次渲染依赖高度，延迟一帧
      requestAnimationFrame(() => {
        ensureMinimapDots();
        updateMinimapViewport();
        renderMinimapState();
      });

      window.addEventListener("scroll", () => {
        updateMinimapViewport();
      }, { passive: true });

      window.addEventListener("resize", () => {
        ensureMinimapDots();
        updateMinimapViewport();
        renderMinimapState();
      });

      if (elBtnApplySel){
        elBtnApplySel.addEventListener("click", applyPendingSelection);
        elBtnApplySel.disabled = true;
      }
    }

    init();
  </script>
</body>
</html>

